// TC:  O(n²)
//  SC: O(1)

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size(); // অ্যারের সাইজ বের করা

        // অ্যারে sort করা যাতে দুই-পয়েন্টার টেকনিক ব্যবহার করা যায়
        sort(nums.begin(), nums.end());

        vector<vector<int>> ans; // রেজাল্ট সংরক্ষণের জন্য 2D ভেক্টর

        // i হলো প্রথম পয়েন্টার, 0 থেকে n-1 পর্যন্ত লুপ চালানো হবে
        for (int i = 0; i < n; i++) {

            // ডুপ্লিকেট এড়াতে: যদি আগের i এর ভ্যালুর সমান হয়, তাহলে স্কিপ করা
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // দুই পয়েন্টার ইনিশিয়ালাইজ: j (i এর পরে) এবং k (শেষে)
            int j = i + 1;
            int k = n - 1;

            // যতক্ষণ j ছোট k এর চেয়ে, লুপ চালানো
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k]; // তিনটি সংখ্যার যোগফল বের করা

                if (sum > 0) {
                    // যদি যোগফল বেশি হয়, তাহলে বড় সংখ্যা কমানোর জন্য k কমানো
                    k--;
                }
                else if (sum < 0) {
                    // যদি যোগফল কম হয়, তাহলে ছোট সংখ্যা বাড়ানোর জন্য j বাড়ানো
                    j++;
                }
                else {
                    // যদি sum == 0 হয়, তাহলে ট্রিপলেট পাওয়া গেছে
                    ans.push_back({nums[i], nums[j], nums[k]});

                    // ডুপ্লিকেট এড়াতে j কে সামনে নিয়ে যাওয়া
                    while (j < k && nums[j] == nums[j + 1]) j++;

                    // ডুপ্লিকেট এড়াতে k কে পিছনে নিয়ে যাওয়া
                    while (j < k && nums[k] == nums[k - 1]) k--;

                    // পরবর্তী সম্ভাব্য জোড়ার জন্য j++ এবং k-- করা
                    j++;
                    k--;
                }
            }
        }
        return ans; // ফাইনাল রেজাল্ট রিটার্ন
    }
};

